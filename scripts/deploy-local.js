const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");

async function main() {
    console.log("üöÄ D√©marrage du d√©ploiement local des contrats Rent2Repay...");

    // R√©cup√©rer le compte de d√©ploiement
    const [deployer] = await ethers.getSigners();
    console.log("üìã D√©ploiement depuis le compte:", deployer.address);
    console.log("üí∞ Solde du compte:", ethers.formatEther(await deployer.provider.getBalance(deployer.address)), "ETH");

    // Objet pour stocker toutes les adresses d√©ploy√©es
    const deployedAddresses = {
        network: "localhost",
        chainId: 31337,
        deployer: deployer.address,
        deployedAt: new Date().toISOString(),
        contracts: {}
    };

    try {
        // ===== √âTAPE 1: D√©ployer les tokens de test =====
        console.log("\nüìù === √âTAPE 1: D√©ploiement des tokens de test ===");

        const MockERC20Factory = await ethers.getContractFactory("MockERC20");

        // D√©ployer USDC mock
        console.log("ü™ô D√©ploiement de MockUSDC...");
        const mockUSDC = await MockERC20Factory.deploy("Mock USDC", "USDC");
        await mockUSDC.waitForDeployment();
        const usdcAddress = await mockUSDC.getAddress();
        deployedAddresses.contracts.MockUSDC = usdcAddress;
        console.log("‚úÖ MockUSDC d√©ploy√© √†:", usdcAddress);

        // D√©ployer WXDAI mock
        console.log("ü™ô D√©ploiement de MockWXDAI...");
        const mockWXDAI = await MockERC20Factory.deploy("Mock Wrapped XDAI", "WXDAI");
        await mockWXDAI.waitForDeployment();
        const wxdaiAddress = await mockWXDAI.getAddress();
        deployedAddresses.contracts.MockWXDAI = wxdaiAddress;
        console.log("‚úÖ MockWXDAI d√©ploy√© √†:", wxdaiAddress);

        // ===== NOUVEAUX TOKENS DE SUPPLY LIQUIDITY =====
        // D√©ployer armmUSDC (Supply Liquidity Token pour USDC)
        console.log("üè¶ D√©ploiement de armmUSDC...");
        const armmUSDC = await MockERC20Factory.deploy("Aave RMM Variable Supply USDC", "armmUSDC");
        await armmUSDC.waitForDeployment();
        const armmUSDCAddress = await armmUSDC.getAddress();
        deployedAddresses.contracts.armmUSDC = armmUSDCAddress;
        console.log("‚úÖ armmUSDC d√©ploy√© √†:", armmUSDCAddress);

        // D√©ployer armmWXDAI (Supply Liquidity Token pour WXDAI)
        console.log("üè¶ D√©ploiement de armmWXDAI...");
        const armmWXDAI = await MockERC20Factory.deploy("Aave RMM Variable Supply WXDAI", "armmWXDAI");
        await armmWXDAI.waitForDeployment();
        const armmWXDAIAddress = await armmWXDAI.getAddress();
        deployedAddresses.contracts.armmWXDAI = armmWXDAIAddress;
        console.log("‚úÖ armmWXDAI d√©ploy√© √†:", armmWXDAIAddress);

        // D√©ployer MockDAOToken
        console.log("ü™ô D√©ploiement de MockDAOToken...");
        const mockDAOToken = await MockERC20Factory.deploy("Mock DAO Token", "DAO");
        await mockDAOToken.waitForDeployment();
        const daoTokenAddress = await mockDAOToken.getAddress();
        deployedAddresses.contracts.MockDAOToken = daoTokenAddress;
        console.log("‚úÖ MockDAOToken d√©ploy√© √†:", daoTokenAddress);

        // ===== √âTAPE 2: D√©ployer les tokens de dette =====
        console.log("\nüìù === √âTAPE 2: D√©ploiement des tokens de dette ===");

        const MockDebtTokenFactory = await ethers.getContractFactory("MockDebtToken");

        // D√©ployer debt token pour USDC
        console.log("üè¶ D√©ploiement de MockDebtUSDC...");
        const mockDebtUSDC = await MockDebtTokenFactory.deploy("Aave Variable Debt USDC", "armmv3USDC", usdcAddress);
        await mockDebtUSDC.waitForDeployment();
        const debtUSDCAddress = await mockDebtUSDC.getAddress();
        deployedAddresses.contracts.MockDebtUSDC = debtUSDCAddress;
        console.log("‚úÖ MockDebtUSDC d√©ploy√© √†:", debtUSDCAddress);

        // D√©ployer debt token pour WXDAI
        console.log("üè¶ D√©ploiement de MockDebtWXDAI...");
        const mockDebtWXDAI = await MockDebtTokenFactory.deploy("Aave Variable Debt WXDAI", "armmv3WXDAI", wxdaiAddress);
        await mockDebtWXDAI.waitForDeployment();
        const debtWXDAIAddress = await mockDebtWXDAI.getAddress();
        deployedAddresses.contracts.MockDebtWXDAI = debtWXDAIAddress;
        console.log("‚úÖ MockDebtWXDAI d√©ploy√© √†:", debtWXDAIAddress);

        // ===== √âTAPE 3: D√©ployer le MockRMM =====
        console.log("\nüìù === √âTAPE 3: D√©ploiement du MockRMM ===");

        const MockRMMFactory = await ethers.getContractFactory("MockRMM");
        console.log("üèóÔ∏è D√©ploiement de MockRMM avec les paires token/debtToken...");

        // Pr√©parer les tableaux pour le constructeur (SEULEMENT LES STABLECOINS ONT DES DEBT TOKENS)
        const tokens = [usdcAddress, wxdaiAddress];
        const debtTokens = [debtUSDCAddress, debtWXDAIAddress];
        const supplyTokens = [armmUSDCAddress, armmWXDAIAddress]; // Supply tokens pour les withdrawals

        console.log("üìã Configuration des paires:");
        console.log("   - USDC:", usdcAddress, "-> DebtUSDC:", debtUSDCAddress, "-> SupplyUSDC:", armmUSDCAddress);
        console.log("   - WXDAI:", wxdaiAddress, "-> DebtWXDAI:", debtWXDAIAddress, "-> SupplyWXDAI:", armmWXDAIAddress);

        const mockRMM = await MockRMMFactory.deploy(tokens, debtTokens, supplyTokens);
        await mockRMM.waitForDeployment();
        const rmmAddress = await mockRMM.getAddress();
        deployedAddresses.contracts.MockRMM = rmmAddress;
        console.log("‚úÖ MockRMM d√©ploy√© √†:", rmmAddress);

        // ===== √âTAPE 3.5: Approvisionnement du MockRMM =====
        console.log("\nüí∞ === √âTAPE 3.5: Approvisionnement du MockRMM en liquidit√© ===");

        // Mint 100000 USDC au MockRMM (6 decimales)
        const usdcAmount = ethers.parseUnits("100000", 6);
        await mockUSDC.mint(rmmAddress, usdcAmount);
        console.log(`‚úÖ ${ethers.formatUnits(usdcAmount, 6)} USDC (${usdcAmount} Wei) mint√©s au MockRMM`);

        // Mint 100000 WXDAI au MockRMM (18 decimales)
        const wxdaiAmount = ethers.parseUnits("100000", 18);
        await mockWXDAI.mint(rmmAddress, wxdaiAmount);
        console.log(`‚úÖ ${ethers.formatUnits(wxdaiAmount, 18)} WXDAI (${wxdaiAmount} Wei) mint√©s au MockRMM`);

        // V√©rifier les balances
        const rmmUsdcBalance = await mockUSDC.balanceOf(rmmAddress);
        const rmmWxdaiBalance = await mockWXDAI.balanceOf(rmmAddress);
        console.log(`üìä Balance MockRMM USDC: ${ethers.formatUnits(rmmUsdcBalance, 6)} USDC (${rmmUsdcBalance} Wei)`);
        console.log(`üìä Balance MockRMM WXDAI: ${ethers.formatUnits(rmmWxdaiBalance, 18)} WXDAI (${rmmWxdaiBalance} Wei)`);

        // ===== √âTAPE 4: D√©ployer le contrat principal Rent2Repay =====
        console.log("\nüìù === √âTAPE 4: D√©ploiement du contrat Rent2Repay ===");

        const { upgrades } = require("hardhat");
        const Rent2RepayFactory = await ethers.getContractFactory("Rent2Repay");
        console.log("üè† D√©ploiement de Rent2Repay avec proxy upgradable...");

        // Le constructeur attend: admin, emergency, operator, rmm, wxdaiToken, wxdaiArmmToken, usdcToken, usdcArmmToken
        const rent2Repay = await upgrades.deployProxy(Rent2RepayFactory, [
            deployer.address, // admin
            deployer.address, // emergency
            deployer.address, // operator
            rmmAddress, // rmm
            wxdaiAddress, // wxdaiToken
            armmWXDAIAddress, // wxdaiArmmToken
            usdcAddress, // usdcToken
            armmUSDCAddress // usdcArmmToken
        ], {
            initializer: 'initialize',
            kind: 'uups'
        });
        await rent2Repay.waitForDeployment();
        const rent2RepayAddress = await rent2Repay.getAddress();
        deployedAddresses.contracts.Rent2Repay = rent2RepayAddress;
        console.log("‚úÖ Rent2Repay d√©ploy√© √†:", rent2RepayAddress);

        // V√©rifier que les tokens sont bien configur√©s
        const wxdaiConfig = await rent2Repay.tokenConfig(wxdaiAddress);
        const usdcConfig = await rent2Repay.tokenConfig(usdcAddress);

        console.log(
            wxdaiConfig.active && wxdaiConfig.token.toLowerCase() === wxdaiAddress.toLowerCase()
                ? "‚úÖ check WXDAI token configuration"
                : "‚ùå check WXDAI token configuration",
            wxdaiConfig.token
        );
        console.log(
            usdcConfig.active && usdcConfig.token.toLowerCase() === usdcAddress.toLowerCase()
                ? "‚úÖ check USDC token configuration"
                : "‚ùå check USDC token configuration",
            usdcConfig.token
        );

        // ===== √âTAPE 5: Configuration initiale =====
        console.log("\nüìù === √âTAPE 5: Configuration initiale ===");

        // Les paires de tokens sont d√©j√† autoris√©es par le constructeur
        console.log("‚úÖ Paires de tokens USDC/DebtUSDC et WXDAI/DebtWXDAI pr√©-autoris√©es par le constructeur");
        console.log("‚ÑπÔ∏è armmUSDC et armmWXDAI sont des tokens de supply ind√©pendants (pas de remboursement de dette)");

        // Configurer l'adresse de la tr√©sorerie DAO (utilise le d√©ployeur pour les tests)
        await rent2Repay.updateDaoTreasuryAddress(deployer.address);
        console.log("‚úÖ Adresse de la tr√©sorerie DAO configur√©e:", deployer.address);

        // Configurer le token de r√©duction des frais DAO
        await rent2Repay.updateDaoFeeReductionToken(daoTokenAddress);
        console.log("‚úÖ Token de r√©duction des frais DAO configur√©:", daoTokenAddress);

        // V√©rification de la configuration du token de gouvernance
        const daoConfig = await rent2Repay.getDaoFeeReductionConfiguration();
        console.log(
            daoConfig.token.toLowerCase() === daoTokenAddress.toLowerCase()
                ? "‚úÖ V√©rification du token de gouvernance: Configuration correcte"
                : "‚ùå V√©rification du token de gouvernance: ERREUR DE CONFIGURATION",
            "\n   ‚Üí Attendu:", daoTokenAddress,
            "\n   ‚Üí Re√ßu:", daoConfig.token
        );

        // Configurer le montant minimum pour la r√©duction des frais (1000 tokens)
        const minAmountForFeeReduction = ethers.parseEther("1000");
        await rent2Repay.updateDaoFeeReductionMinimumAmount(minAmountForFeeReduction);
        console.log("‚úÖ Montant minimum pour r√©duction des frais configur√©:", ethers.formatEther(minAmountForFeeReduction));

        // === V√âRIFICATIONS DE CONFIGURATION ===
        console.log("\nüîç === V√âRIFICATIONS DE CONFIGURATION ===");

        // V√©rifier que la configuration compl√®te de r√©duction des frais DAO est correcte
        const finalDaoConfig = await rent2Repay.getDaoFeeReductionConfiguration();

        console.log("üìã Configuration finale de r√©duction des frais DAO:");
        console.log(`   ü™ô Token de r√©duction: ${finalDaoConfig.token}`);
        console.log(`   üí∞ Montant minimum: ${finalDaoConfig.minimumAmount} wei (${ethers.formatEther(finalDaoConfig.minimumAmount)} tokens)`);
        console.log(`   üìä Pourcentage de r√©duction: ${finalDaoConfig.reductionPercentage} BPS (${Number(finalDaoConfig.reductionPercentage) / 100}%)`);
        console.log(`   üè¶ Adresse treasury: ${finalDaoConfig.treasuryAddress}`);

        // V√©rifications de s√©curit√©
        const configChecks = {
            tokenSet: finalDaoConfig.token !== ethers.ZeroAddress,
            minimumAmountSet: finalDaoConfig.minimumAmount > 0n,
            treasurySet: finalDaoConfig.treasuryAddress !== ethers.ZeroAddress,
            reductionPercentageValid: finalDaoConfig.reductionPercentage > 0n && finalDaoConfig.reductionPercentage <= 10000n
        };

        console.log("\n‚úÖ Checks de configuration:");
        console.log(`   ${configChecks.tokenSet ? '‚úÖ' : '‚ùå'} Token de r√©duction d√©fini: ${configChecks.tokenSet}`);
        console.log(`   ${configChecks.minimumAmountSet ? '‚úÖ' : '‚ùå'} Montant minimum d√©fini: ${configChecks.minimumAmountSet}`);
        console.log(`   ${configChecks.treasurySet ? '‚úÖ' : '‚ùå'} Adresse treasury d√©finie: ${configChecks.treasurySet}`);
        console.log(`   ${configChecks.reductionPercentageValid ? '‚úÖ' : '‚ùå'} Pourcentage de r√©duction valide: ${configChecks.reductionPercentageValid}`);

        const allConfigValid = Object.values(configChecks).every(check => check === true);
        console.log(`\n${allConfigValid ? 'üéâ' : '‚ö†Ô∏è'} Configuration des frais DAO: ${allConfigValid ? 'COMPL√àTE ET VALIDE' : 'INCOMPL√àTE OU INVALIDE'}`);

        if (!allConfigValid) {
            console.warn("‚ö†Ô∏è ATTENTION: La configuration des frais DAO n'est pas compl√®te. Certaines fonctionnalit√©s pourraient ne pas fonctionner.");
        }

        // Ajouter des informations de liaison pour les tests
        deployedAddresses.tokenPairs = [
            {
                token: usdcAddress,
                debtToken: debtUSDCAddress,
                name: "USDC",
                symbol: "USDC",
                type: "stablecoin"
            },
            {
                token: wxdaiAddress,
                debtToken: debtWXDAIAddress,
                name: "WXDAI",
                symbol: "WXDAI",
                type: "stablecoin"
            }
        ];

        // Ajouter les tokens de supply s√©par√©ment (pas de paires dans Rent2Repay)
        deployedAddresses.supplyTokens = [
            {
                token: armmUSDCAddress,
                underlyingAsset: usdcAddress,
                name: "armmUSDC",
                symbol: "armmUSDC",
                type: "supply_liquidity"
            },
            {
                token: armmWXDAIAddress,
                underlyingAsset: wxdaiAddress,
                name: "armmWXDAI",
                symbol: "armmWXDAI",
                type: "supply_liquidity"
            }
        ];

        // R√©cup√©rer la configuration r√©elle depuis le contrat pour la sauvegarder
        const [actualDaoFees, actualSenderTips] = await rent2Repay.getFeeConfiguration();
        const actualDaoConfig = await rent2Repay.getDaoFeeReductionConfiguration();

        deployedAddresses.configuration = {
            daoFeesBPS: Number(actualDaoFees),
            senderTipsBPS: Number(actualSenderTips),
            daoFeeReductionBPS: Number(actualDaoConfig.reductionPercentage),
            daoFeeReductionMinimumAmount: actualDaoConfig.minimumAmount.toString(),
            daoTreasuryAddress: actualDaoConfig.treasuryAddress,
            daoFeeReductionTokenAddress: actualDaoConfig.token
        };

        console.log("\nüìä Configuration sauvegard√©e (valeurs r√©elles du contrat):");
        console.log(`   üí∞ DAO Fees: ${deployedAddresses.configuration.daoFeesBPS} BPS`);
        console.log(`   üéÅ Sender Tips: ${deployedAddresses.configuration.senderTipsBPS} BPS`);
        console.log(`   üìâ R√©duction DAO: ${deployedAddresses.configuration.daoFeeReductionBPS} BPS`);
        console.log(`   üíé Montant minimum: ${deployedAddresses.configuration.daoFeeReductionMinimumAmount} wei`);
        console.log(`   ü™ô Token r√©duction: ${deployedAddresses.configuration.daoFeeReductionTokenAddress}`);
        console.log(`   üè¶ Treasury: ${deployedAddresses.configuration.daoTreasuryAddress}`);

        // ===== √âTAPE 6: Configuration des approbations =====
        console.log("\nüìù === √âTAPE 6: Configuration des approbations ===");

        // Configurer les approbations pour tous les tokens vers le RMM
        const maxApproval = ethers.MaxUint256; // type(uint256).max

        console.log("üîì Configuration des approbations pour les tokens vers RMM...");

        // Approbation pour USDC
        await rent2Repay.giveApproval(usdcAddress, rmmAddress, maxApproval);
        console.log("‚úÖ Approbation configur√©e: USDC ‚Üí RMM");

        // Approbation pour WXDAI
        await rent2Repay.giveApproval(wxdaiAddress, rmmAddress, maxApproval);
        console.log("‚úÖ Approbation configur√©e: WXDAI ‚Üí RMM");

        // Approbation pour armmUSDC (supply token)
        await rent2Repay.giveApproval(armmUSDCAddress, rmmAddress, maxApproval);
        console.log("‚úÖ Approbation configur√©e: armmUSDC ‚Üí RMM");

        // Approbation pour armmWXDAI (supply token)
        await rent2Repay.giveApproval(armmWXDAIAddress, rmmAddress, maxApproval);
        console.log("‚úÖ Approbation configur√©e: armmWXDAI ‚Üí RMM");

        // V√©rifier les approbations directement via IERC20
        console.log("\nüîç V√©rification des approbations:");
        const usdcAllowance = await mockUSDC.allowance(rent2RepayAddress, rmmAddress);
        const wxdaiAllowance = await mockWXDAI.allowance(rent2RepayAddress, rmmAddress);
        const armmUSDCAllowance = await armmUSDC.allowance(rent2RepayAddress, rmmAddress);
        const armmWXDAIAllowance = await armmWXDAI.allowance(rent2RepayAddress, rmmAddress);

        console.log(`   USDC ‚Üí RMM: ${usdcAllowance.toString()} (${usdcAllowance > 0n ? '‚úÖ' : '‚ùå'})`);
        console.log(`   WXDAI ‚Üí RMM: ${wxdaiAllowance.toString()} (${wxdaiAllowance > 0n ? '‚úÖ' : '‚ùå'})`);
        console.log(`   armmUSDC ‚Üí RMM: ${armmUSDCAllowance.toString()} (${armmUSDCAllowance > 0n ? '‚úÖ' : '‚ùå'})`);
        console.log(`   armmWXDAI ‚Üí RMM: ${armmWXDAIAllowance.toString()} (${armmWXDAIAllowance > 0n ? '‚úÖ' : '‚ùå'})`);

        console.log("\n‚úÖ === D√âPLOIEMENT TERMIN√â AVEC SUCC√àS ===");

    } catch (error) {
        console.error("‚ùå Erreur lors du d√©ploiement:", error);
        process.exit(1);
    }

    // ===== √âTAPE 7: Sauvegarder les adresses =====
    console.log("\nüìù === √âTAPE 7: Sauvegarde de la configuration ===");

    const configPath = path.join(__dirname, "tmp/", "deployed-contracts.json");
    fs.writeFileSync(configPath, JSON.stringify(deployedAddresses, null, 2));
    console.log("üíæ Configuration sauvegard√©e dans:", configPath);

    // Afficher un r√©sum√©
    console.log("\nüìä === R√âSUM√â DU D√âPLOIEMENT ===");
    console.log("üè† Rent2Repay:", deployedAddresses.contracts.Rent2Repay);
    console.log("üèóÔ∏è MockRMM:", deployedAddresses.contracts.MockRMM);
    console.log("ü™ô MockUSDC:", deployedAddresses.contracts.MockUSDC);
    console.log("ü™ô MockWXDAI:", deployedAddresses.contracts.MockWXDAI);
    console.log("üè¶ armmUSDC:", deployedAddresses.contracts.armmUSDC);
    console.log("üè¶ armmWXDAI:", deployedAddresses.contracts.armmWXDAI);
    console.log("ü™ô MockDAOToken:", deployedAddresses.contracts.MockDAOToken);
    console.log("üè¶ MockDebtUSDC:", deployedAddresses.contracts.MockDebtUSDC);
    console.log("üè¶ MockDebtWXDAI:", deployedAddresses.contracts.MockDebtWXDAI);

    console.log("\nüîß Pour utiliser ces contrats, r√©f√©rez-vous au fichier:", configPath);
    console.log("üéØ R√©seau: localhost (http://127.0.0.1:8545)");
    console.log("‚õìÔ∏è Chain ID: 31337");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    }); 